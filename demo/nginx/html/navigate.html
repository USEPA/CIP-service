<!DOCTYPE html>
<html lang="en" >
   <head>
      <meta charset="UTF-8">
      <title>CIP Service Navigation</title>
      <link rel='stylesheet' href='https://unpkg.com/leaflet@1.9.4/dist/leaflet.css'>
      <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css'>
      <style>
         #busy {
           position: absolute;
           top: 15%;
           left: 820px;
           z-index: 100;
         }
      </style>
      <script src="./config.js" onerror="return null;"></script>
   </head>
   <body>
      <div id="busy">
         <svg width="57" height="57" viewBox="0 0 57 57" xmlns="http://www.w3.org/2000/svg" stroke="#000">
            <g fill="none" fill-rule="evenodd">
               <g transform="translate(1 1)" stroke-width="2">
                  <circle cx="5" cy="50" r="5">
                     <animate attributeName="cy" begin="0s" dur="2.2s" values="50;5;50;50" calcMode="linear" repeatCount="indefinite" />
                     <animate attributeName="cx" begin="0s" dur="2.2s" values="5;27;49;5" calcMode="linear" repeatCount="indefinite" />
                  </circle>
                  <circle cx="27" cy="5" r="5">
                     <animate attributeName="cy" begin="0s" dur="2.2s" from="5" to="5" values="5;50;50;5" calcMode="linear" repeatCount="indefinite" />
                     <animate attributeName="cx" begin="0s" dur="2.2s" from="27" to="27" values="27;49;5;27" calcMode="linear" repeatCount="indefinite" />
                  </circle>
                  <circle cx="49" cy="50" r="5">
                     <animate attributeName="cy" begin="0s" dur="2.2s" values="50;50;5;50" calcMode="linear" repeatCount="indefinite" />
                     <animate attributeName="cx" from="49" to="49" begin="0s" dur="2.2s" values="49;5;27;49" calcMode="linear" repeatCount="indefinite" />
                  </circle>
               </g>
            </g>
         </svg>
      </div>
      <div id="container" style="width: 1400px;">
         <div id="map" class="map" style="height: 700px; width: 800px; float: left;"></div>
         <div id="righty" style="width: 600px; float: left;">
            <div id="top" style="text-align: center;">
               <h2>&nbsp;</h2>
               <h2 style="margin-top:0px; margin-bottom: 3px;">CIP Service Navigation Test Harness</h2>
               <span style="font-family: Arial; font-size: 11px;">Add points to the map or enter GeoJSON text:</span>
               <br/>
               <input id="start_point"  name="start_point"  type="text" class="textbox" style="width: 400px;" onchange="updatept(this.value);blank_start_nhdplusids();check_start();" />
               <br/>
               <input id="stop_point" name="stop_point" type="text" class="textbox" style="width: 400px;" onchange="updatept2(this.value);blank_stop_nhdplusids();check_start();" />
               <br/>
               <span style="font-family: Arial; font-size: 12px;">NHDPlus Version:&nbsp;</span>
               <select name="resolution" id="resolution" style="font-family: Arial; font-size: 11px; width:170px" onChange="change_resolution();">
                  <option value="nhdplus_m">Medium Resolution</option>
                  <option value="nhdplus_h" SELECTED>High Resolution</option>
               </select>
               <br/>
               <table border="0" align="center">
                 <tr>
                   <td colspan="2" style="font-family: Arial; font-size: 11px;padding-top: 5px;">Or enter NHDPlus identifiers and optional Measures</td>
                 </tr>
                 <tr>
                   <td align="right" style="font-family: Arial; font-size: 11px;">Start NHDPlusID:
                     <input name="start_nhdplusid" type="text" class="text" id="start_nhdplusid" style="display:inline; width:150px" onChange ="blank_pt1();check_start();"/>
                   </td>
                   <td align="right" style="font-family: Arial; font-size: 11px;">Stop NHDPlusID:
                     <input name="stop_nhdplusid" type="text" class="text" id="stop_nhdplusid" style="display:inline; width:150px" onChange ="blank_pt2();check_start();"/>
                   </td>
                 </tr>
                 <tr>
                   <td align="right" style="font-family: Arial; font-size: 11px;">Start Perm Id: 
                     <input name="start_permanent_identifier" type="text" class="text" id="start_permanent_identifier" style="display:inline; width:150px" onChange ="blank_pt1();check_start();"/>
                   </td>
                   <td align="right" style="font-family: Arial; font-size: 11px;">Stop Perm Id: 
                     <input name="stop_permanent_identifier" type="text" class="text" id="stop_permanent_identifier" style="display:inline; width:150px" onChange ="blank_pt2();check_start();"/>
                   </td>
                 </tr>
                 <tr>
                   <td align="right" style="font-family: Arial; font-size: 11px;">Start Reach Code: 
                     <input name="start_reachcode" type="text" class="text" id="start_reachcode" style="display:inline; width:150px" onChange ="blank_pt1();check_start();"/>
                   </td>
                   <td align="right" style="font-family: Arial; font-size: 11px;">Stop Reach Code: 
                     <input name="stop_reachcode" type="text" class="text" id="stop_reachcode" style="display:inline; width:150px" onChange ="blank_pt2();check_start();"/>
                   </td>
                 </tr>
                 <tr>
                   <td align="right" style="font-family: Arial; font-size: 11px;">Start Hydro Seq: 
                     <input name="start_hydrosequence" type="text" class="text" id="start_hydrosequence" style="display:inline; width:150px" onChange ="blank_pt1();check_start();"/>
                   </td>
                   <td align="right" style="font-family: Arial; font-size: 11px;">Stop Hydro Seq: 
                     <input name="stop_hydrosequence" type="text" class="text" id="stop_hydrosequence" style="display:inline; width:150px" onChange ="blank_pt2();check_start();"/>
                   </td>
                 </tr>
                 <tr>
                   <td align="right" style="font-family: Arial; font-size: 11px;">Start Measure:
                     <input name="start_measure" type="text" class="text" id="start_measure" style="display:inline; width:150px" onChange ="blank_pt1();check_start();"/>
                   </td>
                   <td align="right" style="font-family: Arial; font-size: 11px;">Stop Measure:
                     <input name="stop_measure" type="text" class="text" id="stop_measure" style="display:inline; width:150px" onChange ="blank_pt2();check_start();"/>
                   </td>
                 </tr>
               </table>
               <select name="search_type" id="search_type" onchange="update_form();check_start();" style="margin-top: 6px;">
                 <option value="UT" SELECTED>Upstream with Tributaries</option>
                 <option value="UM">Upstream Main Path Only</option>
                 <option value="DD">Downstream with Divergences</option>
                 <option value="DM">Downstream Main Path Only</option>
                 <option value="PP">Point to Point</option>
                 <option value="PPALL">Point to Point, All Streams Between</option>
               </select>
               &nbsp;<input name="search_max" type="text" class="text" id="search_max" style="display:inline; width:30px" value="15" />&nbsp;
               <select name="max_type" id="max_type">
                  <option value="distkm" SELECTED>km (distance)</option>
                  <option value="flowday"> day (flowtime)</option>
               </select>
               
               <br/>
               <br/>
               <input type="button" onclick="run_service();" value="Start Search" id="dz_run_service" />&nbsp;
               <input type="button" onclick="dz_reset();" value="Clear" name="dz_reset" id="dz_reset" />&nbsp;
               
               <br/>
               <br/>
               <br/>
               <br/>
               <input type="button" value="Link" name="dz_link" id="dz_link" />
               <input name="dz_link_text" type="text" class="text" id="dz_link_text" style="display:inline; width:350px" value="" />
               
            </div>
         </div>
      </div>
      <div id="output" style="width: 1200px; text-align: left; font-family: Arial; font-size: 15px;" />
      </div>
      <script src='https://unpkg.com/leaflet@1.9.4/dist/leaflet.js'></script>
      <script src='https://unpkg.com/esri-leaflet@3.0.14/dist/esri-leaflet.js'></script>
      <script src='https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js'></script>
      <script>
   ////////////////////////////////////////////////////////////////////////////
   const queryString = window.location.search;
   const urlParams = new URLSearchParams(queryString);
   let   lat  = urlParams.get('lat');
   let   lng  = urlParams.get('lng');
   let   zoom = urlParams.get('zoom');
   let   rez  = urlParams.get('resolution');
   let   styp = urlParams.get('search_type');
   let   mdst = urlParams.get('maxdistancekm');
   let   mftd = urlParams.get('maxflowtimeday');
   let   pnt  = urlParams.get('start_point');
   let   pnt2 = urlParams.get('stop_point');
   let   nhd1 = urlParams.get('start_nhdplusid');
   let   per1 = urlParams.get('start_permanent_identifier');
   let   rch1 = urlParams.get('start_reachcode');
   let   hsq1 = urlParams.get('start_hydrosequence');
   let   mes1 = urlParams.get('start_measure');
   let   nhd2 = urlParams.get('stop_nhdplusid');
   let   per2 = urlParams.get('stop_permanent_identifier');
   let   rch2 = urlParams.get('stop_reachcode');
   let   hsq2 = urlParams.get('stop_hydrosequence');
   let   mes2 = urlParams.get('stop_measure');
      
   if (lat === " " || lat == null) {
      lat = 46.874626;
   }
   
   if (lng === " " || lng == null) {
      lng = -96.782341;
   }

   if (zoom === " " || zoom == null) {
      zoom = 12;
   }
   
   if (rez === " " || rez == null) {
      rez = "nhdplus_h";
   } else {
      const z = rez.toUpperCase();
      if (z == "HR" || z == "H" || z == "NHDPLUS_H") {
         rez = "nhdplus_h";
      } else if (z == "MR" || z == "M" || z == "NHDPLUS_M") {
         rez = "nhdplus_m";
      } else {
         rez = "nhdplus_h";
      }
   
   }
   document.getElementById("resolution").value = rez;
   
   if (styp === " " || styp == null) {
      styp = "UT";
   } else {
      styp = styp.toUpperCase();
   }
   document.getElementById("search_type").value = styp;
   
   if (mdst === " " || mdst == null) {
      if (mftd === " " || mftd == null) {
         ;
      } else {
         document.getElementById("max_type").value = "flowday";
         document.getElementById("search_max").value = mftd;
      }
   } else {
      document.getElementById("max_type").value = "distkm";
      document.getElementById("search_max").value = mdst;
   }
   
   if (pnt === " " || pnt == null) {
      ;
   } else {
      document.getElementById("start_point").value = pnt;
   }
   
   if (pnt2 === " " || pnt2 == null) {
      ;
   } else {
      document.getElementById("stop_point").value = pnt2;
   }
   
   if (nhd1 === " " || nhd1 == null) {
      ;
   } else {
      document.getElementById("start_nhdplusid").value = nhd1;
   }
   
   if (per1 === " " || per1 == null) {
      ;
   } else {
      document.getElementById("start_permanent_identifier").value = per1;
   }
   
   if (rch1 === " " || rch1 == null) {
      ;
   } else {
      document.getElementById("start_reachcode").value = rch1;
   }
   
   if (hsq1 === " " || hsq1 == null) {
      ;
   } else {
      document.getElementById("start_hydrosequence").value = hsq1;
   }
   
   if (mes1 === " " || mes1 == null) {
      ;
   } else {
      document.getElementById("start_measure").value = mes1;
   }
   
   if (nhd2 === " " || nhd2 == null) {
      ;
   } else {
      document.getElementById("stop_nhdplusid").value = nhd2;
   }
   
   if (per2 === " " || per2 == null) {
      ;
   } else {
      document.getElementById("stop_permanent_identifier").value = per2;
   }
   
   if (rch2 === " " || rch2 == null) {
      ;
   } else {
      document.getElementById("stop_reachcode").value = rch2;
   }
   
   if (hsq2 === " " || hsq2 == null) {
      ;
   } else {
      document.getElementById("stop_hydrosequence").value = hsq2;
   }
   
   if (mes2 === " " || mes2 == null) {
      ;
   } else {
      document.getElementById("stop_measure").value = mes2;
   }
   
   ////////////////////////////////////////////////////////////////////////////
   const linkButton = document.getElementById('dz_link');
   linkButton.addEventListener('click', () => {
     let p = new URLSearchParams();
     let c = map.getCenter();
     p.append('lat',c.lat);
     p.append('lng',c.lng);
     p.append('zoom',map.getZoom()); 
     
     p.append('resolution',get_select_values(document.getElementById("resolution")));
     p.append('search_type',get_select_values(document.getElementById("search_type")));
     
     const mxtyp = get_select_values(document.getElementById("max_type"));
     if (mxtyp == "distkm") {
        p.append('maxdistancekm',document.getElementById("search_max").value);
     } else {
        if (mxtyp == "flowday") {
           p.append('maxflowtimeday',document.getElementById("search_max").value);
        }
     }
     
     const pt1 = document.getElementById("start_point").value;
     if (pt1 != null && pt1 !== "") {
        p.append('start_point',pt1);
     }
     
     const pt2 = document.getElementById("stop_point").value;
     if (pt2 != null && pt2 !== "") {
        p.append('stop_point',pt2);
     }
     
     const nhd1 = document.getElementById("start_nhdplusid").value;
     if (nhd1 != null && nhd1 !== "") {
        p.append('start_nhdplusid',nhd1);
     }
     
     const per1 = document.getElementById("start_permanent_identifier").value;
     if (per1 != null && per1 !== "") {
        p.append('start_permanent_identifier',per1);
     }
     
     const rch1 = document.getElementById("start_reachcode").value;
     if (rch1 != null && rch1 !== "") {
        p.append('start_reachcode',rch1);
     }
     
     const hyd1 = document.getElementById("start_hydrosequence").value;
     if (hyd1 != null && hyd1 !== "") {
        p.append('start_hydrosequence',hyd1);
     }
     
     const mes1 = document.getElementById("start_measure").value;
     if (mes1 != null && mes1 !== "") {
        p.append('start_measure',mes1);
     }
     
     const nhd2 = document.getElementById("stop_nhdplusid").value;
     if (nhd2 != null && nhd2 !== "") {
        p.append('stop_nhdplusid',nhd2);
     }
     
     const per2 = document.getElementById("stop_permanent_identifier").value;
     if (per2 != null && per2 !== "") {
        p.append('stop_permanent_identifier',per2);
     }
     
     const rch2 = document.getElementById("stop_reachcode").value;
     if (rch2 != null && rch2 !== "") {
        p.append('stop_reachcode',rch2);
     }
     
     const hyd2 = document.getElementById("stop_hydrosequence").value;
     if (hyd2 != null && hyd2 !== "") {
        p.append('stop_hydrosequence',hyd2);
     }
     
     const mes2 = document.getElementById("stop_measure").value;
     if (mes2 != null && mes2 !== "") {
        p.append('stop_measure',mes2);
     }
     
     let linktext = window.location.origin + window.location.pathname + '?' + p.toString();
     //console.log(linktext);
     document.getElementById("dz_link_text").value = linktext;
     
   });
   
   ////////////////////////////////////////////////////////////////////////////
   document.getElementById("dz_run_service").disabled = true;
   document.getElementById("busy").style.visibility = "hidden";
   update_form();
   
   var map = L.map("map").setView([lat,lng],zoom);
   mapLink = '<a href="http://openstreetmap.org">OpenStreetMap</a>';

   basemap = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: "Map data &copy; " + mapLink,
      maxZoom: 18
   });
   basemap.addTo(map);
   
   var lyr_nhdplus_m_flowlines = null;
   var lyr_nhdplus_h_flowlines = null;
   
   var drawnItems = new L.FeatureGroup().addTo(map);
   var drawControl = new L.Control.Draw({
      draw: {
          polygon: false
         ,polyline: false
         ,rectangle: false
         ,circle: false
         ,marker: true
         ,circlemarker: false
      },
      edit: {
         featureGroup: drawnItems,
         edit: false,
         remove: true
      }
   });
   map.addControl(drawControl);
   
   map.on(L.Draw.Event.CREATED, function(e) {
      var type = e.layerType;
      var layer = e.layer;

      const sm = document.getElementById("search_type");
      const st = sm.options[sm.selectedIndex].value;
      const lc = drawnItems.getLayers().length;

      if (st == "PP" || st == "PPALL") {
         if (lc == 2) {
            drawnItems.clearLayers();
            blank_pts();
            blank_nhdplusids();
            document.getElementById("dz_run_service").disabled = true;
         } 
      } else {
         if (lc == 1) {
            drawnItems.clearLayers();
            blank_pts();
            blank_nhdplusids();
            document.getElementById("dz_run_service").disabled = true;
         }
      }

      if (type === "marker") {
         if (st == "PP" || st == "PPALL") {
            if (lc != 1) {
               var start_geojsonval = JSON.stringify(layer.toGeoJSON().geometry);

               document.getElementById("start_point").value = start_geojsonval;
               layer.bindPopup(start_geojsonval);
               blank_start_nhdplusids();
               
            } else if (lc == 1) {
               var stop_geojsonval = JSON.stringify(layer.toGeoJSON().geometry);
               
               document.getElementById("stop_point").value = stop_geojsonval;
               layer.bindPopup(stop_geojsonval);
               blank_stop_nhdplusids();

               document.getElementById("dz_run_service").disabled = false;
            }
            
         } else {
            var start_geojsonval = JSON.stringify(layer.toGeoJSON().geometry);

            document.getElementById("start_point").value = start_geojsonval;
            layer.bindPopup(start_geojsonval);
            blank_start_nhdplusids();

            document.getElementById("dz_run_service").disabled = false;
         }
      }

      drawnItems.addLayer(layer);
      check_start();
   });

   map.on(L.Draw.Event.DELETED, function(e) {
      var layer_count = drawnItems.getLayers().length;

      if (layer_count == 1) {
         document.getElementById("stop_point").value = "";
      } else {
         document.getElementById("start_point").value = "";
      }

      document.getElementById("dz_run_service").disabled = true;
   });
   
   var snap_path = L.geoJson(null, {
      onEachFeature: onEachFeature_snap_path
   }).addTo(map);
   
   var flowlines = new L.GeoJSON(null, {
      onEachFeature: onEachFeature_flowlines
   }).addTo(map);
   
   var layer_items = {
     "Snap path": snap_path,
     "Returned Streams": flowlines
   };
   
   if (
      typeof gis_host === "undefined" ||
      gis_host === null ||
      gis_host == "NONE"
   ) {
      null;
   } else {
      zgis_host = gis_host;
      
      if (
         typeof gis_type === "undefined" ||
         gis_type === null ||
         gis_type == "NONE"
      ) {
         zgis_type = "geoserver";
      } else {
         zgis_type = gis_type;
      }
   
      if (
         typeof gis_prot === "undefined" ||
         gis_prot === null ||
         gis_prot == "NONE"
      ) {
         zgis_prot = "http";
      } else {
         zgis_prot = gis_prot;
      }
      
      if (
         typeof gis_port === "undefined" ||
         gis_port === null ||
         gis_port == "NONE"
      ) {
         zgis_port = "";
      } else {
         zgis_port = ":" + gis_port;
      }
      
      if ( zgis_type == "geoserver" ) {
         gis_server = zgis_prot + "://" + zgis_host + zgis_port;
         const nv = get_select_values(document.getElementById("resolution"));
         
         lyr_nhdplus_m_flowlines = L.tileLayer.wms(gis_server + "/wms",{
             layers: 'cipsrv:nhdplus_m_flowlines'
            ,format: 'image/png'
            ,transparent: true
            ,version: '1.3.0'
            ,attribution: "US EPA"
         });
         
         if (nv == "nhdplus_m" ) {
            lyr_nhdplus_m_flowlines.addTo(map);
         }
         
         layer_items["MR Flowlines"] = lyr_nhdplus_m_flowlines;
         
         lyr_nhdplus_h_flowlines = L.tileLayer.wms(gis_server + "/wms",{
             layers: 'cipsrv:nhdplus_h_flowlines'
            ,format: 'image/png'
            ,transparent: true
            ,version: '1.3.0'
            ,attribution: "US EPA"
         });
         
         if (nv == "nhdplus_h" ) {
            lyr_nhdplus_h_flowlines.addTo(map);
         }
         layer_items["HR Flowlines"] = lyr_nhdplus_h_flowlines;
         
      }
      
   }
   L.control.layers(null, layer_items).addTo(map);

   check_start();
   
   function dzStr(val) {
      if (val == 0 ) {
         return "0";
      } else if (!val) {
         return "";
      } else {
         return val.toString();
      }
   }   
   
   function onEachFeature_snap_path(feature,layer) {
      if (feature.properties && feature.properties.snap_distancekm) {
         layer.bindPopup(
            "Length (Km): " +
            dzStr(feature.properties.snap_distancekm)
         );
      }
   }
   
   function onEachFeature_flowlines(feature,layer) {
      if (feature.properties && feature.properties.nhdplusid) {
         layer.bindPopup(
            "NHDPlusID: " +
            dzStr(feature.properties.nhdplusid) +
            "<BR/>" +
            "Perm ID: " +
            feature.properties.permanent_identifier +
            "<BR/>" +
            "FCode: " +
            dzStr(feature.properties.fcode) +
            "<BR/>" +
            "Reach Code: " +
            feature.properties.reachcode +
            "<BR/>" +
            "Hydro Seq: " +
            dzStr(feature.properties.hydroseq) +
            "<BR/>" +
            "FMeasure: " +
            dzStr(feature.properties.fmeasure) +
            "<BR/>" +
            "TMeasure: " +
            dzStr(feature.properties.tmeasure) +
            "<BR/>" +
            "Down Hydro Seq: " +
            dzStr(feature.properties.dnhydroseq) +
            "<BR/>" +
            "Terminal Path ID: " +
            dzStr(feature.properties.terminalpa) +
            "<BR/>" +
            "GNIS Name: " +
            feature.properties.gnis_name +
            "<BR/>" +
            "Length (Km): " +
            dzStr(feature.properties.lengthkm) +
            "<BR/>" +
            "Network Distance (Km): " +
            dzStr(feature.properties.network_distancekm) +
            "<BR/>" 
         );
      }
   }

   function run_service() {
      dz_clear_old();
      busy_on();

      const sp = document.getElementById("start_point").value;
      const nv = get_select_values(document.getElementById("resolution"));
      if (sp == "" ) {
         
         const st = get_select_values(document.getElementById("search_type"));
         
         const mt = get_select_values(document.getElementById("max_type"));
         let mxkm;
         let mxday;
         if (mt == "distkm" ) {
            mxkm  = document.getElementById("search_max").value;
            mxday = null;
         }
         if (mt == "flowday" ) {
            mxkm  = null;
            mxday = document.getElementById("search_max").value;
         }
         
         var data = {
             "search_type"               : st
            ,"nhdplus_version"           : nv
             
            ,"start_nhdplusid"           : document.getElementById("start_nhdplusid").value
            ,"start_permanent_identifier": document.getElementById("start_permanent_identifier").value
            ,"start_reachcode"           : document.getElementById("start_reachcode").value
            ,"start_hydroseq"            : document.getElementById("start_hydrosequence").value
            ,"start_measure"             : document.getElementById("start_measure").value
            
            ,"stop_nhdplusid"            : document.getElementById("stop_nhdplusid").value
            ,"stop_permanent_identifier" : document.getElementById("stop_permanent_identifier").value
            ,"stop_reachcode"            : document.getElementById("stop_reachcode").value
            ,"stop_hydroseq"             : document.getElementById("stop_hydrosequence").value
            ,"stop_measure"              : document.getElementById("stop_measure").value
            
            ,"max_distancekm"            : mxkm
            ,"max_flowtimeday"           : mxday
            ,"return_flowline_details"   : true
            ,"return_flowline_geometry"  : true
         }
      
         httpPost(
            build_api() + "navigate",
            data,
            nav_response
         );
      
      } else {
         if (sp !== "") {

            var data = {
                "point"           : JSON.parse(sp)
               ,"nhdplus_version" : nv
               ,"limit_navigable" : true
               ,"return_link_path": true
            }
      
            httpPost(
               build_api() + "pointindexing",
               data,
               pt1_response
            );
         
         } 
      
      }
      
   }
   
   function httpPost(url,data,callback) {
      var xmlHttp = new XMLHttpRequest();
      xmlHttp.open("POST",url,true);
      xmlHttp.setRequestHeader('Content-Type','application/json');
      xmlHttp.responseType = 'json';
      xmlHttp.onreadystatechange = function() {
         if(xmlHttp.readyState === 4) {
            if(xmlHttp.status === 200) {
               response = xmlHttp.response;
               callback(null,response);
            } else {
               callback(xmlHttp.statusText,null);
            }
         }
      };
      xmlHttp.send(JSON.stringify(data));
   }

   function get_select_values(sval){
      let result = null;
      
      if ( sval == null ) {
         return result;
      }
      
      if ( sval.options == null ) {
         return result;
      }
      
      if ( sval.selectedIndex == null ) {
         return result;
      }
      //console.log(sval);
      return sval.options[sval.selectedIndex].value;
   
   }
   
   function get_mselect_values(sval){
      let result = [];
      let options = sval && sval.options;
      let opt;
      
      if ( options == null ) {
         return result;
      }

      for (var i=0, iLen=options.length; i<iLen; i++) {
         opt = options[i];

         if (opt.selected) {
            result.push(opt.value || opt.text);
         }
      }
      return result;
   }
   
   function nav_response(error,response) {
      busy_off();

      if (error) {
         document.getElementById("output").innerHTML = "<P>" + error + "</P>";
         return false;
      } else if (response == null) {
         document.getElementById("output").innerHTML = "<P>No response from service.</P>";
         return false;
      } else if (response.return_code != 0) {
         document.getElementById("output").innerHTML = "<P>" + response.status_message + "</P>";
         return false;
      } else if (response.catchment_count == 0) {
         document.getElementById("output").innerHTML = "<P>No catchments indexed.</P>";
      }
      
      if (response.flowlines !== null && response.flowlines.features[0].geometry.type !== null) {
         flowlines.addData(response.flowlines).setStyle({
             "color": "#0000FF"
            ,"fillColor": "#0000FF"
            ,"weight": 4
         });
         
         map.fitBounds(flowlines.getBounds(), {
            maxZoom: 16
         });
         
         document.getElementById("output").innerHTML = "<P>&nbsp;</P><P align='center'>Flowline Count: " + response.flowline_count + "</P>";
         
      }            
   }
   
   function pt1_response(error,response) {
      if (error) {
         document.getElementById("output").innerHTML = "<P>" + error + "</P>";
         return false;
      } else if (response == null) {
         document.getElementById("output").innerHTML = "<P>No response from service.</P>";
         return false;
      } else if (response.return_code != 0) {
         document.getElementById("output").innerHTML = "<P>" + response.status_message + "</P>";
         return false;
      } else if (response.catchment_count == 0) {
         document.getElementById("output").innerHTML = "<P>No catchments indexed.</P>";
      }
      
      if (response.indexing_line !== null && response.indexing_line.type !== null) {
         snap_path.addData(response.indexing_line).setStyle({
             "color": "#FFA500"
            ,"fillColor": "#FFA500"
         });
         
         document.getElementById("start_nhdplusid").value           = response.flowlines.features[0].properties.nhdplusid;
         document.getElementById("start_permanent_identifier").value = response.flowlines.features[0].properties.permanent_identifier;
         document.getElementById("start_reachcode").value           = response.flowlines.features[0].properties.reachcode;
         document.getElementById("start_hydrosequence").value            = response.flowlines.features[0].properties.hydroseq;
         document.getElementById("start_measure").value             = response.flowlines.features[0].properties.snap_measure;
         
      }

      var stop_geojsonval  = document.getElementById("stop_point").value;
      const nv  = get_select_values(document.getElementById("resolution"));
      if (stop_geojsonval !== "") {
         
         var data = {
             "point"           : JSON.parse(stop_geojsonval)
            ,"nhdplus_version" : nv
            ,"limit_navigable" : true
            ,"return_link_path": true
         }
      
         httpPost(
            build_api() + "pointindexing",
            data,
            pt2_response
         );
      
      } else {
         const st      = get_select_values(document.getElementById("search_type"));
         
         const mt      = get_select_values(document.getElementById("max_type"));
         var mxkm,mxday;
         if (mt == "distkm" ) {
            mxkm  = document.getElementById("search_max").value;
            mxday = null;
         }
         if (mt == "flowday" ) {
            mxkm  = null;
            mxday = document.getElementById("search_max").value;
         }
      
         var data = {
             "search_type"               : st
            ,"nhdplus_version"           : nv
             
            ,"start_nhdplusid"           : document.getElementById("start_nhdplusid").value
            ,"start_permanent_identifier": document.getElementById("start_permanent_identifier").value
            ,"start_reachcode"           : document.getElementById("start_reachcode").value
            ,"start_hydroseq"            : document.getElementById("start_hydrosequence").value
            ,"start_measure"             : document.getElementById("start_measure").value
            
            ,"stop_nhdplusid"            : document.getElementById("stop_nhdplusid").value
            ,"stop_permanent_identifier" : document.getElementById("stop_permanent_identifier").value
            ,"stop_reachcode"            : document.getElementById("stop_reachcode").value
            ,"stop_hydroseq"             : document.getElementById("stop_hydrosequence").value
            ,"stop_measure"              : document.getElementById("stop_measure").value
            
            ,"max_distancekm"            : mxkm
            ,"max_flowtimeday"           : mxday
            ,"return_flowline_details"   : true
            ,"return_flowline_geometry"  : true
         }
      
         httpPost(
            build_api() + "navigate",
            data,
            nav_response
         );
      }
      
   }
   
   function pt2_response(error,response) {
      if (error) {
         document.getElementById("output").innerHTML = "<P>" + error + "</P>";
         return false;
      } else if (response == null) {
         document.getElementById("output").innerHTML = "<P>No response from service.</P>";
         return false;
      } else if (response.return_code != 0) {
         document.getElementById("output").innerHTML = "<P>" + response.status_message + "</P>";
         return false;
      } else if (response.catchment_count == 0) {
         document.getElementById("output").innerHTML = "<P>No catchments indexed.</P>";
      }
      
      if (response.indexing_line !== null && response.indexing_line.type !== null) {
         snap_path.addData(response.indexing_line).setStyle({
             "color": "#FFA500"
            ,"fillColor": "#FFA500"
         });
         
         document.getElementById("stop_nhdplusid").value           = response.flowlines.features[0].properties.nhdplusid;
         document.getElementById("stop_permanent_identifier").value = response.flowlines.features[0].properties.permanent_identifier;
         document.getElementById("stop_reachcode").value           = response.flowlines.features[0].properties.reachcode;
         document.getElementById("stop_hydrosequence").value            = response.flowlines.features[0].properties.hydroseq;
         document.getElementById("stop_measure").value             = response.flowlines.features[0].properties.snap_measure;
         
      }
      
      const nv  = get_select_values(document.getElementById("resolution"));
      const st  = get_select_values(document.getElementById("search_type"));
      
      const mt  = get_select_values(document.getElementById("max_type"));
      let mxkm;
      let mxday;
      if (mt == "distkm" ) {
         mxkm  = document.getElementById("search_max").value;
         mxday = null;
      }
      if (mt == "flowday" ) {
         mxkm  = null;
         mxday = document.getElementById("search_max").value;
      }
   
      var data = {
          "search_type"               : st
         ,"nhdplus_version"           : nv
          
         ,"start_nhdplusid"           : document.getElementById("start_nhdplusid").value
         ,"start_permanent_identifier": document.getElementById("start_permanent_identifier").value
         ,"start_reachcode"           : document.getElementById("start_reachcode").value
         ,"start_hydroseq"            : document.getElementById("start_hydrosequence").value
         ,"start_measure"             : document.getElementById("start_measure").value
         
         ,"stop_nhdplusid"            : document.getElementById("stop_nhdplusid").value
         ,"stop_permanent_identifier" : document.getElementById("stop_permanent_identifier").value
         ,"stop_reachcode"            : document.getElementById("stop_reachcode").value
         ,"stop_hydroseq"             : document.getElementById("stop_hydrosequence").value
         ,"stop_measure"              : document.getElementById("stop_measure").value
         
         ,"max_distancekm"            : mxkm
         ,"max_flowtimeday"           : mxday
         ,"return_flowline_details"   : true
         ,"return_flowline_geometry"  : true
      }
      
      httpPost(
         build_api() + "navigate",
         data,
         nav_response
      );
      
   }
   
   function dz_reset() {
      document.getElementById("output").innerHTML = "";
      document.getElementById("dz_link_text").value = "";
      snap_path.clearLayers();
      flowlines.clearLayers();
      blank_pts();
      blank_nhdplusids()
      busy_off();
      document.getElementById("dz_run_service").disabled = true;
   }
   
   function dz_clear_old() {
      document.getElementById("output").innerHTML = "";
      snap_path.clearLayers();
      flowlines.clearLayers();
      busy_off();
      document.getElementById("dz_run_service").disabled = true;
   }

   function busy_on() {
      document.getElementById("busy").style.visibility = "visible";
      document.body.style.cursor = "wait";
      document.getElementById("dz_run_service").disabled = true;
   }

   function busy_off() {
      document.getElementById("busy").style.visibility = "hidden";
      document.body.style.cursor = "auto";
      document.getElementById("dz_run_service").disabled = false;
   }
   
   function blank_pts() {
      drawnItems.clearLayers();
      document.getElementById("start_point").value = "";
      document.getElementById("stop_point").value = "";
   }

   function blank_pt1() {
      document.getElementById("start_point").value = "";
   }

   function blank_pt2() {
      document.getElementById("stop_point").value = "";
   }
   
   function change_resolution() {
      const nv = get_select_values(document.getElementById("resolution"));
      blank_nhdplusids();

      if (lyr_nhdplus_m_flowlines !== null && nv == "nhdplus_m" ) {
         if (map.hasLayer(lyr_nhdplus_h_flowlines) ) {
            map.removeLayer(lyr_nhdplus_h_flowlines);
         }
         if (! map.hasLayer(lyr_nhdplus_m_flowlines) ) {
            map.addLayer(lyr_nhdplus_m_flowlines);
         }

      } else if (lyr_nhdplus_h_flowlines !== null && nv == "nhdplus_h" ) {
         if (map.hasLayer(lyr_nhdplus_m_flowlines) ) {
            map.removeLayer(lyr_nhdplus_m_flowlines);
         }
         if (! map.hasLayer(lyr_nhdplus_h_flowlines) ) {
            map.addLayer(lyr_nhdplus_h_flowlines);
         }

      }
   }
    
   function blank_nhdplusids() {
      blank_start_nhdplusids();
      blank_stop_nhdplusids();
   }

   function blank_start_nhdplusids() {
      document.getElementById("start_nhdplusid").value = "";
      document.getElementById("start_permanent_identifier").value = "";
      document.getElementById("start_reachcode").value = "";
      document.getElementById("start_hydrosequence").value = "";
      document.getElementById("start_measure").value = "";
   }

   function blank_stop_nhdplusids() {
      document.getElementById("stop_nhdplusid").value = "";
      document.getElementById("stop_permanent_identifier").value = "";
      document.getElementById("stop_reachcode").value = "";
      document.getElementById("stop_hydrosequence").value = "";
      document.getElementById("stop_measure").value = "";
   }

   function check_start() {
      const st = get_select_values(document.getElementById("search_type"));

      const pt1 = document.getElementById("start_point").value;
      const pt2 = document.getElementById("stop_point").value;

      const com1 = document.getElementById("start_nhdplusid").value;
      const per1 = document.getElementById("start_permanent_identifier").value;
      const rch1 = document.getElementById("start_reachcode").value;
      const hyd1 = document.getElementById("start_hydrosequence").value;

      const com2 = document.getElementById("stop_nhdplusid").value;
      const per2 = document.getElementById("stop_permanent_identifier").value;
      const rch2 = document.getElementById("stop_reachcode").value;
      const hyd2 = document.getElementById("stop_hydrosequence").value;

      if (st != "PP" && st != "PPALL" && pt1 !== null && pt1 !== "") {
         document.getElementById("dz_run_service").disabled = false;

      } else if (
         ( st == "PP" || st == "PPALL" ) &&
         pt1 !== null &&
         pt1 !== "" &&
         pt2 !== null &&
         pt2 !== ""
      ) {
         document.getElementById("dz_run_service").disabled = false;

      } else {
         if (st == "PP" || st == "PPALL") {
            if (
               (com1 !== null && com1 !== "") ||
               (per1 !== null && per1 !== "") ||
               (rch1 !== null && rch1 !== "") ||
               (hyd1 !== null && hyd1 !== "") 
            ) {
               if (
                 (com1 !== null && com1 !== "") ||
                 (per1 !== null && per1 !== "") ||
                 (rch1 !== null && rch1 !== "") ||
                 (hyd1 !== null && hyd1 !== "")
               ) {
                  document.getElementById("dz_run_service").disabled = false;
               } else {
                  document.getElementById("dz_run_service").disabled = true;
               }
               
            }
         } else {
         
            if (
              (com1 !== null && com1 !== "") ||
              (per1 !== null && per1 !== "") ||
              (rch1 !== null && rch1 !== "") ||
              (hyd1 !== null && hyd1 !== "") 
            ) {
              document.getElementById("dz_run_service").disabled = false;
            } else {            
              document.getElementById("dz_run_service").disabled = true;
            }
            
         }
      }
   }
   
   function update_form() {
      const st = get_select_values(document.getElementById("search_type"));

      if (st == "PP" || st == "PPALL") {
         document.getElementById("stop_nhdplusid").disabled = false;
         document.getElementById("stop_permanent_identifier").disabled = false;
         document.getElementById("stop_reachcode").disabled = false;
         document.getElementById("stop_hydrosequence").disabled = false;
         document.getElementById("stop_measure").disabled = false;
         document.getElementById("stop_point").disabled = false;
         document.getElementById("search_max").disabled = true;
      } else {
         document.getElementById("stop_nhdplusid").disabled = true;
         document.getElementById("stop_permanent_identifier").disabled = true;
         document.getElementById("stop_reachcode").disabled = true;
         document.getElementById("stop_hydrosequence").disabled = true;
         document.getElementById("stop_measure").disabled = true;
         document.getElementById("stop_point").disabled = true;
         document.getElementById("search_max").disabled = false;
      }
   }

   function get_url_parameter(param_key) {
      const pu = window.location.search.substring(1);
      
      var url_variables = pu.split('&');
      for (var i = 0; i < url_variables.length; i++) {
         var parameter_name = url_variables[i].split('=');
         if (parameter_name[0] == param_key) {
            return parameter_name[1];
         }
      }
      return null;
   }
   
   function updatept(geojson) {
      if (geojson == null || geojson == undefined || geojson == "") {
         document.getElementById("dz_run_service").disabled = true;
      } else {
         const sm = document.getElementById("search_type");
         const st = sm.options[sm.selectedIndex].value;
         var drawnl      = drawnItems.getLayers();
         var drawn_count = layers.length;

         blank_nhdplusids();
         if (drawn_count == 2) {
            null;
         } else if (drawn_count == 1) {
            null;
         } else {
            null;
         }               
      }
   }
   
   function updatept2(geojson) {
      if (geojson == null || geojson == undefined || geojson == "") {
         document.getElementById("dz_run_service").disabled = true;
      } else {
         const sm = document.getElementById("search_type");
         const st = sm.options[sm.selectedIndex].value;
         var drawnl      = drawnItems.getLayers();
         var drawn_count = layers.length;

         blank_nhdplusids();
         if (drawn_count == 2) {
            null;
         } else if (drawn_count == 1) {
            null;
         } else {
            null;
         } 
      }
   }
   
   function build_api() {
      
      if (
         typeof postgrest_host === "undefined" ||
         postgrest_host === null ||
         postgrest_host == "NONE"
      ) {
         zpostgrest_host = get_url_parameter("postgrest_host");
      } else {
         zpostgrest_host = postgrest_host;
      }

      if (
         typeof postgrest_port === "undefined" ||
         postgrest_port === null ||
         postgrest_port == "NONE"
      ) {
         zpostgrest_port = get_url_parameter("postgrest_port");
      } else {
         zpostgrest_port = postgrest_port;
      }

      if (
         typeof postgrest_pref === "undefined" ||
         postgrest_pref === null ||
         postgrest_pref == "NONE"
      ) {
         zpostgrest_pref = get_url_parameter("postgrest_pref");
      } else {
         zpostgrest_pref = postgrest_pref;
      }
      
      if (zpostgrest_pref === null ) {
         zpostgrest_pref = "";
      } else {
         zpostgrest_pref = zpostgrest_pref + "/";
      }

      if (zpostgrest_host === null) {
         console.log("no PostgREST API server location defined.");
         return;
      }

      var http = "http";
      if (zpostgrest_port == "443") {
         http = "https";
      }
      
      return http +
         "://" +
         zpostgrest_host +
         ":" +
         zpostgrest_port + "/" + 
         zpostgrest_pref + "rpc/";
         
   }
          
      </script>
   </body>
</html>
